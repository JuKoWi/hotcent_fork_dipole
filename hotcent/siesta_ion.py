#-----------------------------------------------------------------------------#
#   Hotcent: calculating one- and two-center Slater-Koster integrals,         #
#            based on parts of the Hotbit code                                #
#   Copyright 2018-2021 Maxime Van den Bossche                                #
#   SPDX-License-Identifier: GPL-3.0-or-later                                 #
#-----------------------------------------------------------------------------#
import numpy as np
from ase.data import atomic_masses, atomic_numbers
from hotcent.atomic_base import nl2tuple


def write_ion(atom, label=None, npts=500, threshold=1e-12):
    """ Writes a '.ion' file with the necessary basis set and
    pseudopotential-related information for Siesta (together
    with the 'User.Basis = True' option)

    Parameter
    ---------
    atom : PseudoAtomicDFT object
        Fully initialized pseudo-atom.
    label : str or None, optional
        If not None, the output file will be named '<label>.ion'
        and the corresponding value will be filled in the 'label' field.
        If None (the default), '<symbol>.<xctype>' will be used as
        a label (with xctype=lda/gga).
    npts : int, optional
        Number of grid points for tabulating the radial quantities
        (default: 500).
    threshold : float, optional
        Threshold used for determining the cutoff radii of the tabulated
        quantities (radial basis functions, KB projectors, ...). Beyond
        a cutoff radius all values will have a magnitude below the
        given threshold (default: 1e-12).
    """
    assert atom.pp.local_component == 'siesta'

    lines = ['<preamble>', 'File generated by Hotcent' , '</preamble>']

    xctype = 'gga' if atom.xc.add_gradient_corrections else 'lda'
    label = '{0}.{1}'.format(atom.symbol, xctype) if label is None else label

    lmaxorb, norb = 0, 0
    for valence in atom.basis_sets:
        for nl in valence:
            n, l = nl2tuple(nl)
            lmaxorb = max(lmaxorb, l)
            norb += 1

    lmaxkb, nkb = 0, 0
    for nl in atom.pp.projectors:
        n, l = nl2tuple(nl)
        lmaxkb = max(lmaxkb, l)
        nkb += 1

    mass = atomic_masses[atomic_numbers[atom.symbol]]
    self_energy = atom.pp.get_self_energy() * 2  # Ha to Ry

    lines += [
        '{0}  # Symbol'.format(atom.symbol),
        '{0}  # Label'.format(label),
        '{0:8d}  # Atomic number'.format(atom.Z),
        '{0:20.8f}  # Valence charge'.format(atom.pp.Zval),
        '{0:20.8f}  # Mass'.format(mass),
        '{0:20.8f}  # Self energy'.format(self_energy),
        '{0:4d}{1:4d}  # Lmax for basis, no. of nl orbs.'.format(lmaxorb, norb),
        '{0:4d}{1:4d}  # Lmax for proj., no. of nl proj.'.format(lmaxkb, nkb),
    ]

    # radial basis functions
    lines.append('# PAOs:' + '_'*20)
    for ibas, valence in enumerate(atom.basis_sets):
        for nl in valence:
            n, l = nl2tuple(nl)
            z = ibas + 1
            is_minimal = nl in atom.valence
            is_pol = 1 if (ibas == 0 and not is_minimal) else 0
            occ = atom.configuration[nl] if (ibas == 0 and is_minimal) else 0.
            items = [l, n, z, is_pol, occ]
            line = '{0:3d}{1:3d}{2:3d}{3:3d}{4:10.6f}'.format(*items)
            line += '  # subshell l, n, zeta, is_polarized, occupation'
            lines.append(line)
            table = get_array_table(atom.Rnl_fct[nl], atom.rmin, npts,
                                    threshold=threshold, exponent=l)
            lines.extend(table)

    lines.append('# KBs:' + '_'*20)
    counter = 1
    for nl in atom.pp.projectors:
        n, l = nl2tuple(nl)
        e_ref = atom.pp.energies[nl] * 2  # Ha to Ry
        line = '{0:3d}{1:3d}{2:20.14f}'.format(l, counter, e_ref)
        line += '  # KB l, n (sequence number), e_KB'
        lines.append(line)
        table = get_array_table(atom.pp.projectors[nl], atom.rmin, npts,
                                threshold=threshold, exponent=l)
        lines.extend(table)
        counter += 1

    lines.append('# Vna:' + '_'*20)
    _ = atom.neutral_atom_potential(1.)
    table = get_array_table(atom.vna_fct, atom.rmin, npts, factor=2,  # Ha to Ry
                            threshold=threshold)
    lines.extend(table)

    lines.append('# Chlocal:' + '_'*20)
    _ = atom.pp.get_local_density(1.)
    table = get_array_table(atom.pp.rho_loc_fct, atom.rmin, npts,
                            threshold=threshold)
    lines.extend(table)

    if atom.pp.has_nonzero_rho_core:
        lines.append('# Core:' + '_'*20)
        _ = atom.pp.get_local_density(1.)
        table = get_array_table(atom.pp.rho_core_fct, atom.rmin, npts,
                                threshold=threshold)
        lines.extend(table)

    lines += ['']
    content = '\n'.join(lines)

    filename = '{0}.ion'.format(label)
    with open(filename, 'w') as f:
        f.write(content)
    return


def get_array_table(interpolator, rmin, npts, factor=1, exponent=0,
                    threshold=None):
    if threshold is None:
        cutoff = interpolator.x[-1]
    else:
        for cutoff in interpolator.x[::-1]:
            if abs(interpolator(cutoff)) > threshold:
                break

    delta = cutoff / (npts - 1)
    grid = np.linspace(0., cutoff, num=npts)
    assert np.isclose(grid[1], delta)
    table = [
        '{0:6d}{1:28.18e}{2:20.14f}'.format(npts, delta, cutoff) \
        + '  # npts, delta, cutoff',
    ]

    array = interpolator(grid) * factor

    imin = 1 + int(np.round(rmin / delta))
    array[imin:] /= grid[imin:]**exponent
    array[:imin] = array[imin]

    table += ['{0:30.20e}{1:30.20e}'.format(x, y) for x, y in zip(grid, array)]
    return table
